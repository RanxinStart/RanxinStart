(function() { //自执行函数
	const 未定义 = undefined;
	//先定义初始方法  功能为:成功/失败
	function Promise(执行器) {
		const 自我 = this;
		自我.状态 = '待定';
		自我.数据 = 未定义;
		自我.回调函数 = [];

		function 指定判定成功方法(成功值) {
			//待定才能执行这些方法 为了...
			if (自我.状态 !== '待定') {
				return; //不是待定会退出方法
			}
			//不是待定 所以 判定为成功
			自我.状态 = '成功';
			自我.数据 = 成功值;
			//查看回调函数 是否存在 不存在就后面没有.then了
			if (自我.回调函数.length) { //有才会执行
				// 变成异步函数.. 放到队列后面去
				setTimeout(() => {
					自我.回调函数.forEach((回调函数对象值) => {
						回调函数对象值.客户端成功事件(成功值);
					});
				});
			}
		}

		function 指定判定失败方法(失败值) {
			//复制下来的  ..注释就不改了
			//待定才能执行这些方法 为了...
			if (自我.状态 !== '待定') {
				return; //不是待定会退出方法
			}
			//不是待定 所以 判定为成功
			自我.状态 = '失败';
			自我.数据 = 失败值;
			//查看回调函数 是否存在 不存在就后面没有.then了
			if (自我.回调函数.length) { //有才会执行
				// 变成异步函数.. 放到队列后面去
				setTimeout(() => {
					自我.回调函数.forEach((回调函数对象值) => {
						回调函数对象值.客户端失败事件(失败值);
					});
				});
			}
		}

		try { //出现异常也是失败
			执行器(指定判定成功方法, 指定判定失败方法);
		} catch (失败值或错误值) {
			指定判定失败方法(失败值或错误值);
		}
	}

	//做 原型的.then函数 就.
	Promise.prototype.then = function(客户端成功事件, 客户端失败事件) {
		自我 = this;
		
		return new Promise(指定判定成功方法,指定判定失败方法){
			if(自我.状态 === '待定'){
				自我.回调函数.push({
					客户端成功事件,
					客户端失败事件
				});
			}
		}
		
	}



	window.Promise = Promise;
})(window);
